<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Minigolf P√°lya Viewer - v1.7.0</title>
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />

    <!-- ES6 modules √©s importmap t√°mogat√°s -->
    <script
      async
      src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"
    ></script>

    <!-- Modul√°ris strukt√∫ra -->
    <script src="constants.js"></script>
    <script src="hole-generator.js"></script>
    <script src="csg-manager.js"></script>
    <script src="element-manager.js"></script>
    <script src="model.js"></script>
    <script src="geometry-builder.js"></script>
    <script src="exploder.js"></script>
    <script src="scene-manager.js"></script>
    <script src="view-mode.js"></script>
    <script src="summary.js"></script>
    <script src="shader-loader.js"></script>

    <link rel="stylesheet" href="styles.css" />
  </head>
  <body>
    <!-- Egyszer≈±s√≠tett importmap - csak a sz√ºks√©ges k√∂nyvt√°rak -->
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.158.0/build/three.module.js",
          "three/examples/jsm/exporters/GLTFExporter.js": "https://unpkg.com/three@0.158.0/examples/jsm/exporters/GLTFExporter.js",
          "three-mesh-bvh": "https://unpkg.com/three-mesh-bvh@0.7.6/build/index.module.js",
          "three-bvh-csg": "https://unpkg.com/three-bvh-csg@0.0.17/build/index.module.js"
        }
      }
    </script>

    <div id="viewer-container">
      <!-- F≈ë vez√©rl≈ëk -->
      <div id="controls">
        <button id="toggle-explode">Sz√©tszed√©s</button>
        <button id="toggle-view-mode">Sz√≠nes</button>
        <button id="export-gltf">GLTF Export</button>
      </div>

      <!-- N√©zet v√°lt√≥ gombok -->
      <div id="view-controls">
        <div class="view-label">N√©zetek:</div>
        <button id="view-top">Fel√ºl</button>
        <button id="view-bottom">Alul</button>
        <button id="view-front">El√∂l</button>
        <button id="view-back">H√°tul</button>
        <button id="view-left">Bal</button>
        <button id="view-right">Jobb</button>
        <hr />
        <button id="zoom-in">Zoom +</button>
        <button id="zoom-out">Zoom -</button>
        <hr />
        <button id="reset-view">Alaphelyzet</button>
      </div>
    </div>
    <div id="summary-panel">
      <h1>Minigolf P√°lya Specifik√°ci√≥</h1>
      <!-- A summary javascript-b≈ël lesz felt√∂ltve -->
    </div>

    <!-- CSG inicializ√°l√°s √©s f≈ëalkalmaz√°s -->
    <script type="module">
      // Csak a sz√ºks√©ges k√∂nyvt√°rak import√°l√°sa
      import * as THREE from "three";
      import { GLTFExporter } from "three/examples/jsm/exporters/GLTFExporter.js";
      import * as ThreeMeshBVH from "three-mesh-bvh";
      import * as ThreeBVHCSG from "three-bvh-csg";

      // THREE.js glob√°lisan el√©rhet≈ëv√© t√©tele
      window.THREE = THREE;
      window.GLTFExporter = GLTFExporter;

      // Glob√°lis v√°ltoz√≥k
      let elementManager;
      let sceneManager;
      let geometryBuilder;
      let exploder;
      let viewModeManager;
      let csgManager;
      let allMeshes;
      let shaderLoader;

      // CSG inicializ√°l√°s
      function initializeCSG() {
        try {
          // K√∂nyvt√°rak hozz√°f√©rhet≈ës√©ge ellen≈ërz√©se
          if (!ThreeMeshBVH || !ThreeBVHCSG) {
            console.warn(
              "CSG k√∂nyvt√°rak nem t√∂lt≈ëdtek be, fallback m√≥dra v√°lt√°s"
            );
            return false;
          }

          // Glob√°lis objektumok l√©trehoz√°sa kompatibilit√°s miatt
          window.MeshBVH = ThreeMeshBVH.MeshBVH;
          window.CSGAPI = ThreeBVHCSG;

          // CSG wrapper objektum
          window.CSG = {
            // Alapvet≈ë oszt√°lyok
            Brush: ThreeBVHCSG.Brush,
            Evaluator: ThreeBVHCSG.Evaluator,

            // Oper√°ci√≥k
            ADDITION: ThreeBVHCSG.ADDITION,
            SUBTRACTION: ThreeBVHCSG.SUBTRACTION,
            INTERSECTION: ThreeBVHCSG.INTERSECTION,
            DIFFERENCE: ThreeBVHCSG.DIFFERENCE,

            // Kompatibilit√°si funkci√≥k
            fromMesh: (mesh) => {
              const brush = new ThreeBVHCSG.Brush(mesh.geometry, mesh.material);
              brush.position.copy(mesh.position);
              brush.rotation.copy(mesh.rotation);
              brush.scale.copy(mesh.scale);
              brush.updateMatrixWorld();
              return brush;
            },

            toMesh: (brush, matrix) => {
              const mesh = new THREE.Mesh(brush.geometry, brush.material);
              if (matrix) mesh.applyMatrix4(matrix);
              return mesh;
            },
          };

          console.log("CSG k√∂nyvt√°rak sikeresen inicializ√°lva (ES6 modules)");
          return true;
        } catch (error) {
          console.error("CSG inicializ√°l√°s hiba:", error);
          return false;
        }
      }

      // Shader el√©rhet≈ës√©g ellen≈ërz√©se
      async function checkShaderAvailability() {
        try {
          // Ellen≈ërizz√ºk hogy a ShaderLoader el√©rhet≈ë-e
          if (typeof ShaderLoader === "undefined") {
            console.warn(
              "‚ö†Ô∏è ShaderLoader nem el√©rhet≈ë, DOM fallback haszn√°lata"
            );
            return checkEmbeddedShaders();
          }

          // ShaderLoader inicializ√°l√°sa
          shaderLoader = new ShaderLoader();

          // Shader bet√∂lt√©s k√ºls≈ë f√°jlokb√≥l vagy DOM fallback
          const shaders = await shaderLoader.loadShadersWithFallback();

          if (shaders && shaders.vertex && shaders.fragment) {
            console.log("‚úÖ Minden shader el√©rhet≈ë");

            // Shader k√≥dok glob√°lisan el√©rhet≈ëv√© t√©tele ViewModeManager sz√°m√°ra
            window.toonShaderCode = shaders;

            return true;
          } else {
            console.warn("‚ö†Ô∏è Shader k√≥dok hi√°nyoznak");
            return false;
          }
        } catch (error) {
          console.error("‚ùå Shader ellen≈ërz√©s hiba:", error);
          console.log("üîÑ Fallback DOM shader ellen≈ërz√©sre v√°lt√°s...");
          return checkEmbeddedShaders();
        }
      }

      // DOM-b√≥l shader ellen≈ërz√©s (fallback)
      function checkEmbeddedShaders() {
        // Hozz√°adunk fallback DOM shader elemeket ha nincsenek
        if (!document.getElementById("toonVertexShader")) {
          const vertexScript = document.createElement("script");
          vertexScript.id = "toonVertexShader";
          vertexScript.type = "x-shader/x-vertex";
          vertexScript.textContent = `
            varying vec3 vWorldPosition;
            varying vec3 vNormal;
            varying vec2 vUv;

            void main() {
              vUv = uv;
              vNormal = normalize(normalMatrix * normal);
              vec4 worldPosition = modelMatrix * vec4(position, 1.0);
              vWorldPosition = worldPosition.xyz;
              gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
          `;
          document.head.appendChild(vertexScript);
        }

        if (!document.getElementById("toonFragmentShader")) {
          const fragmentScript = document.createElement("script");
          fragmentScript.id = "toonFragmentShader";
          fragmentScript.type = "x-shader/x-fragment";
          fragmentScript.textContent = `
            uniform vec3 color;
            uniform vec3 lightDirection;
            uniform float paperStrength;
            uniform sampler2D paperTexture;

            varying vec3 vWorldPosition;
            varying vec3 vNormal;
            varying vec2 vUv;

            // Paper noise function
            float hash(vec2 p) {
              return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);
            }

            float noise(vec2 p) {
              vec2 i = floor(p);
              vec2 f = fract(p);
              f = f * f * (3.0 - 2.0 * f);
              return mix(
                mix(hash(i), hash(i + vec2(1.0, 0.0)), f.x),
                mix(hash(i + vec2(0.0, 1.0)), hash(i + vec2(1.0, 1.0)), f.x),
                f.y
              );
            }

            void main() {
              // EGYSZER≈∞S√çTETT vil√°g√≠t√°s - mindig vil√°gos
              float NdotL = max(0.3, dot(normalize(vNormal), normalize(lightDirection)));

              // SOKKAL vil√°gosabb alap√©rtelmezett lighting
              float lightLevel = mix(0.85, 1.0, NdotL); // 80%-100% k√∂z√∂tti vil√°g√≠t√°s

              // Minim√°lis paper text√∫ra
              vec2 paperUv = vUv * 20.0;
              float paperNoise = noise(paperUv) * 0.02; // Nagyon kis hat√°s

              // Tiszta sz√≠nek, minim√°lis √°rny√©kol√°s
              vec3 finalColor = color * lightLevel;
              finalColor += vec3(paperNoise) * paperStrength;

              // Brightening - m√©g vil√°gosabb
              finalColor = mix(finalColor, vec3(1.0), 0.1); // 10% feh√©r hozz√°ad√°sa

              gl_FragColor = vec4(finalColor, 1.0);
            }
          `;
          document.head.appendChild(fragmentScript);
        }

        const shaders = {
          toonVertex: document.getElementById("toonVertexShader"),
          toonFragment: document.getElementById("toonFragmentShader"),
        };

        const missing = Object.entries(shaders)
          .filter(([name, element]) => !element)
          .map(([name]) => name);

        if (missing.length === 0) {
          console.log("‚úÖ Shader-ek el√©rhet≈ëek DOM fallback-b≈ël");
          return true;
        } else {
          console.warn("‚ö†Ô∏è Hi√°nyz√≥ shaderek:", missing);
          return false;
        }
      }

      // F≈ëalkalmaz√°s inicializ√°l√°sa
      async function initialize() {
        try {
          console.log("Inicializ√°l√°s kezdete v1.7.0...");

          // K√∂nyvt√°rak ellen≈ërz√©se
          const csgAvailable = initializeCSG();
          const shadersAvailable = await checkShaderAvailability(); // async!

          // Manager objektumok l√©trehoz√°sa
          elementManager = new ElementManager();
          sceneManager = new SceneManager(
            document.getElementById("viewer-container")
          );
          geometryBuilder = new GeometryBuilder();
          exploder = new Exploder();
          viewModeManager = new ViewModeManager(sceneManager, geometryBuilder);

          // Keresztreferenci√°k be√°ll√≠t√°sa
          exploder.setViewModeManager(viewModeManager);
          viewModeManager.setExploder(exploder);
          console.log("‚úÖ Keresztreferenci√°k be√°ll√≠tva");

          // Shader t√°mogat√°s be√°ll√≠t√°sa
          if (shadersAvailable) {
            viewModeManager.setShadersAvailable(true);
            console.log("Custom shader t√°mogat√°s enged√©lyezve");
          }

          // CSG Manager l√©trehoz√°sa ha el√©rhet≈ë
          if (csgAvailable && typeof CSGManager !== "undefined") {
            csgManager = new CSGManager();
            geometryBuilder.setCSGManager(csgManager);
            console.log("CSG Manager inicializ√°lva");
          } else {
            console.log(
              "CSG Manager nem el√©rhet≈ë, hagyom√°nyos m√≥dban folytat√°s"
            );
          }

          console.log("Manager objektumok l√©trehozva");

          // Scene setup
          sceneManager.setup();
          console.log("Scene setup k√©sz");

          // Elemek bet√∂lt√©se
          minigolfElements.forEach((element) => {
            elementManager.addElement(element);
          });
          console.log(`${minigolfElements.length} elem bet√∂ltve`);

          // Mesh-ek l√©trehoz√°sa
          const elements = elementManager.getAllElements();
          allMeshes = geometryBuilder.createAllMeshes(elements);
          console.log(`${allMeshes.size} mesh l√©trehozva`);

          // Mesh-ek hozz√°ad√°sa a scene-hez
          sceneManager.addAllMeshes(allMeshes);
          console.log("Mesh-ek hozz√°adva a scene-hez");

          // ViewModeManager inicializ√°l√°sa
          viewModeManager.saveOriginalMaterials(allMeshes);
          console.log("Eredeti anyagok mentve");

          // Exploder inicializ√°l√°sa
          exploder.saveOriginalPositions(allMeshes);
          console.log("Eredeti poz√≠ci√≥k mentve");

          // Alap√©rtelmezett tervrajz n√©zet be√°ll√≠t√°sa
          viewModeManager.switchToBlueprint(
            allMeshes,
            elementManager.getAllElements(),
            true
          );
          console.log("Tervrajz n√©zet be√°ll√≠tva alap√©rtelmezettk√©nt");

          // Summary gener√°l√°sa
          const summary = elementManager.generateSummary();
          const summaryPanel = document.getElementById("summary-panel");
          summaryGenerator.renderFullSummary(
            summaryPanel,
            summary,
            elementManager.version
          );
          console.log("Summary gener√°lva");

          // Event listener-ek be√°ll√≠t√°sa
          setupEventListeners();
          console.log("Event listener-ek be√°ll√≠tva");

          console.log("Inicializ√°l√°s sikeres v1.7.0!");
        } catch (error) {
          console.error("Hiba az inicializ√°l√°s sor√°n:", error);
        }
      }

      // Event listener-ek be√°ll√≠t√°sa
      function setupEventListeners() {
        // Sz√©tszed√©s gomb
        document
          .getElementById("toggle-explode")
          .addEventListener("click", function () {
            exploder.toggle(allMeshes, elementManager.getAllElements());

            // Gomb sz√∂veg friss√≠t√©se
            this.textContent = exploder.getState().isExploded
              ? "√ñsszerak√°s"
              : "Sz√©tszed√©s";
          });

        // N√©zet v√°lt√°s gomb
        document
          .getElementById("toggle-view-mode")
          .addEventListener("click", function () {
            viewModeManager.toggle(allMeshes, elementManager.getAllElements());

            // Gomb sz√∂veg friss√≠t√©se
            const newMode =
              viewModeManager.getCurrentMode() === "realistic"
                ? "Tervrajz"
                : "Sz√≠nes";
            this.textContent = newMode;
          });

        // Alaphelyzet gomb
        document
          .getElementById("reset-view")
          .addEventListener("click", function () {
            // Exploded √°llapot vissza√°ll√≠t√°sa
            if (exploder.getState().isExploded) {
              exploder.reset(allMeshes);
              document.getElementById("toggle-explode").textContent =
                "Sz√©tszed√©s";
            }

            // N√©zet vissza√°ll√≠t√°sa (kamera poz√≠ci√≥)
            sceneManager.resetView();
          });

        // Zoom In gomb
        document
          .getElementById("zoom-in")
          .addEventListener("click", function () {
            sceneManager.zoomCamera(-50); // Negat√≠v √©rt√©k = k√∂zelebb
          });

        // Zoom Out gomb
        document
          .getElementById("zoom-out")
          .addEventListener("click", function () {
            sceneManager.zoomCamera(50); // Pozit√≠v √©rt√©k = t√°volabb
          });

        // GLTF export gomb
        document
          .getElementById("export-gltf")
          .addEventListener("click", function () {
            exportGLTF(false);
          });

        // N√©zet v√°lt√≥ gombok
        document
          .getElementById("view-top")
          .addEventListener("click", function () {
            sceneManager.setTopView();
          });

        document
          .getElementById("view-bottom")
          .addEventListener("click", function () {
            sceneManager.setBottomView();
          });

        document
          .getElementById("view-front")
          .addEventListener("click", function () {
            sceneManager.setFrontView();
          });

        document
          .getElementById("view-back")
          .addEventListener("click", function () {
            sceneManager.setBackView();
          });

        document
          .getElementById("view-left")
          .addEventListener("click", function () {
            sceneManager.setLeftView();
          });

        document
          .getElementById("view-right")
          .addEventListener("click", function () {
            sceneManager.setRightView();
          });
      }

      // GLTF export√°l√°si funkci√≥
      async function exportGLTF(binary = false) {
        try {
          // Ha sz√©tszedett √°llapotban van, √°tmenetileg √°ll√≠tsuk vissza
          const wasExploded = exploder.getState().isExploded;
          if (wasExploded) {
            exploder.setPositionImmediate(
              allMeshes,
              elementManager.getAllElements(),
              false
            );
          }

          // Export
          const result = await sceneManager.exportScene(binary);

          // F√°jl ment√©se
          const filename = binary
            ? "minigolf_palya.glb"
            : "minigolf_palya.gltf";

          if (binary) {
            saveArrayBuffer(result, filename);
          } else {
            saveString(JSON.stringify(result, null, 2), filename);
          }

          // Ha sz√©tszedett √°llapotban volt, √°ll√≠tsuk vissza
          if (wasExploded) {
            exploder.setPositionImmediate(
              allMeshes,
              elementManager.getAllElements(),
              true
            );
          }

          console.log(`Export sikeres: ${filename}`);
        } catch (error) {
          console.error("Export hiba:", error);
        }
      }

      // Seg√©df√ºggv√©nyek a f√°jlok ment√©s√©hez
      function saveString(text, filename) {
        const blob = new Blob([text], { type: "text/plain" });
        downloadBlob(blob, filename);
      }

      function saveArrayBuffer(buffer, filename) {
        const blob = new Blob([buffer], { type: "application/octet-stream" });
        downloadBlob(blob, filename);
      }

      function downloadBlob(blob, filename) {
        const link = document.createElement("a");
        link.href = URL.createObjectURL(blob);
        link.download = filename;
        link.click();

        // Cleanup
        setTimeout(() => URL.revokeObjectURL(link.href), 1000);
      }

      // Debug funkci√≥k (fejleszt√©shez)
      async function debugInfo() {
        console.log("=== DEBUG INFO v1.7.0 ===");
        console.log(
          "Element Manager:",
          elementManager.getAllElements().length + " elem"
        );
        console.log("Scene Manager:", sceneManager.getSceneInfo());
        console.log("Exploder:", exploder.getState());
        console.log("View Mode Manager:", viewModeManager.getCapabilities());
        console.log("Mesh-ek:", allMeshes.size);
        console.log("S√∫ly:", elementManager.getTotalWeight().toFixed(2) + " g");
        // CSG debug info
        if (csgManager) {
          console.log("CSG Manager:", csgManager.getDebugInfo());
        }
        console.log("Shaders:", await checkShaderAvailability());
        console.log("==================");
      }

      // Glob√°lis hozz√°f√©r√©s debug-hoz
      window.debugInfo = debugInfo;
      window.elementManager = () => elementManager;
      window.sceneManager = () => sceneManager;
      window.csgManager = () => csgManager;
      window.viewModeManager = () => viewModeManager;
      window.exploder = () => exploder;
      window.shaderLoader = () => shaderLoader;

      // Egyedi elem l√°that√≥s√°g kapcsol√≥ funkci√≥
      window.toggleElementVisibility = function (elementId, isVisible) {
        console.log(`Elem l√°that√≥s√°g v√°lt√°s: ${elementId} -> ${isVisible}`);

        // Elem keres√©se ID szerint
        const mesh = allMeshes.get(elementId);
        if (mesh) {
          mesh.visible = isVisible;

          // Ha blueprint m√≥dban vagyunk, az wireframe layer is kell friss√≠teni
          if (viewModeManager.getCurrentMode() === "blueprint") {
            const wireframeMesh =
              viewModeManager.wireframeLayer?.get(elementId);
            if (wireframeMesh) {
              wireframeMesh.visible = isVisible;
            }

            // Lyuk k√∂rvonalak is friss√≠t√©se
            viewModeManager.wireframeLayer?.forEach((wireframe, key) => {
              if (key.startsWith(`${elementId}_hole_`)) {
                wireframe.visible = isVisible;
              }
            });
          }

          // Render friss√≠t√©s
          sceneManager.renderer.render(sceneManager.scene, sceneManager.camera);
        } else {
          console.warn(`Elem nem tal√°lhat√≥: ${elementId}`);
        }
      };

      // Inicializ√°l√°s ind√≠t√°sa az oldal bet√∂lt√©se ut√°n
      document.addEventListener("DOMContentLoaded", initialize);
    </script>
  </body>
</html>
